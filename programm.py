from tkinter import *
window = Tk()
window.geometry("800x600")
window.title("Kubik Rubika")
# Подключение библиотеки случайных чисел
# Используется для разборки кубика
import random
# Список, используемый для хранения текущего состояния кубика 
# Список из 6 элементов по числу граней, каждый из которых тоже список списков
# В итоге C[i] - это список списков 3х3 - одна из граней
# Порядок строго определенный (указан под списком)
# U - Верхняя грань (Для собранного хранит 11,12,13 14,15,16, 17,18,19)
# L - Левая грань (от 21 до 29)
# F - Передняя грань (от 31 до 39)
# R - Правая грань (от 41 до 49)
# B - Задняя грань (от 51 до 59)
# D - Нижняя грань (от 61 до 69)
C=[[],[],[],[],[],[]]
#  U  L  F  R  B  D
# Список названий основных движений
# Всего их 27, фиксированный набор
# Каждое название состоит из 3 знаков
# 1-й символ ось, относительно которого идет вращение
# X - если смотреть на кубик прямо, то это линия справа-налево, вращение если смотреть на правую грань
# Y - если смотреть на кубик прямо, то это линия сверху-вниз, вращение по часовой - справа налево
# Z - если смотреть на кубик прямо, то это линия прямо, насквозь, вращение если смотреть прямо
# 2-й символ - какая линия вращается 1, 2 или 3
# Зависит от оси
# 3-й символ - направление вращения
# C - 90 градусов по часовой стрелке (один поворот)
# O - 90 градусов против часовой стрелки (один поворот)
# D - поворот на 180 градусов (два поворота)
N=['X1C','X1D','X1O','X2C','X2D','X2O','X3C','X3D','X3O',
'Y1C','Y1D','Y1O','Y2C','Y2D','Y2O','Y3C','Y3D','Y3O',
'Z1C','Z1D','Z1O','Z2C','Z2D','Z2O','Z3C','Z3D','Z3O']
# Список движений. По размеру совпадает со списком N
# Заполняется чуть ниже
# В комментариях номер элемента, начиная с 0, номер начиная с 1, название
# Каждое движение хранит четверки или двойки квадратов, указывающий какой номер куда перемещается
# Например
# [13,33,63,57] - Вместо 13 становится 33, вместо 33 - 63, вместо 63 - 57, а вместо 57 становится 13
# [13,63] - 13 и 63 меняются местами
M=[]
# X
M.append([[13,33,63,57],[16,36,66,54],[19,39,69,51],[41,47,49,43],[42,44,48,46]]) # 00 01 X1C
M.append([[13,63],[33,57],[16,66],[36,54],[19,69],[39,51],[41,49],[47,43],[42,48],[44,46]]) # 01 02 X1D
M.append([[13,57,63,33],[16,54,66,36],[19,51,69,39],[41,43,49,47],[42,46,48,44]]) # 02 03 X1O
M.append([[12,32,62,58],[15,35,65,55],[18,38,68,52]]) # 03 04 X2C
#M.append([[13,57,63,33],[16,54,66,36],[19,51,69,39],[41,43,49,47],[42,46,48,44],
#[11,59,61,31],[14,56,64,34],[17,53,67,37],[21,27,29,23],[22,24,28,26]]) # 03 04 X2C = X1O + X3O
M.append([[12,62],[32,58],[15,65],[35,55],[18,68],[38,52]]) # 04 05 X2D
#M.append([[13,63],[33,57],[16,66],[36,54],[19,69],[39,51],[41,49],[47,43],[42,48],[44,46],
#[11,61],[31,59],[14,64],[34,56],[17,67],[37,53],[21,29],[23,27],[22,28],[26,24]]) # 04 05 X2D = X1D + X3D
M.append([[12,58,62,32],[15,55,65,35],[18,52,68,38]]) # 05 06 X2O
#M.append([[13,33,63,57],[16,36,66,54],[19,39,69,51],[41,47,49,43],[42,44,48,46],
#[11,31,61,59],[14,34,64,56],[17,37,67,53],[21,23,29,27],[22,26,28,24]]) # 05 06 X2O = X1C + X3C
M.append([[11,31,61,59],[14,34,64,56],[17,37,67,53],[21,23,29,27],[22,26,28,24]]) # 06 07 X3C
M.append([[11,61],[31,59],[14,64],[34,56],[17,67],[37,53],[21,29],[23,27],[22,28],[26,24]]) # 07 08 X3D
M.append([[11,59,61,31],[14,56,64,34],[17,53,67,37],[21,27,29,23],[22,24,28,26]]) # 08 09 X3O
# Y
M.append([[21,31,41,51],[22,32,42,52],[23,33,43,53],[11,17,19,13],[12,14,18,16]]) # 09 10 Y1C
M.append([[21,41],[31,51],[22,42],[32,52],[23,43],[33,53],[11,19],[17,13],[12,18],[14,16]]) #  1011 Y1D
M.append([[21,51,41,31],[22,52,42,32],[23,53,43,33],[11,13,19,17],[12,16,18,14]]) # 11 12 Y1O
M.append([[24,34,44,54],[25,35,45,55],[26,36,46,56]]) # 12 13 Y2C
#M.append([[21,51,41,31],[22,52,42,32],[23,53,43,33],[11,13,19,17],[12,16,18,14],
#[27,57,47,37],[28,58,48,38],[29,59,49,39],[61,67,69,63],[62,64,68,66]]) # 12 13 Y2C = Y1O + Y3O
M.append([[24,44],[34,54],[25,45],[35,55],[26,46],[36,56]]) # 13 14 Y2D
#M.append([[21,41],[31,51],[22,42],[32,52],[23,43],[33,53],[11,19],[17,13],[12,18],[14,16],
#[27,47],[37,57],[28,48],[38,58],[29,49],[39,59],[61,69],[63,67],[62,68],[66,64]]) # 13 14 Y2D = Y1D + Y3D
M.append([[24,54,44,34],[25,55,45,35],[26,56,46,36]]) # 14 15 Y2O
#M.append([[21,31,41,51],[22,32,42,52],[23,33,43,53],[11,17,19,13],[12,14,18,16],
#[27,37,47,57],[28,38,48,58],[29,39,49,59],[61,63,69,67],[62,66,68,64]]) # 14 15 Y2O = Y1C + Y3C 
M.append([[27,37,47,57],[28,38,48,58],[29,39,49,59],[61,63,69,67],[62,66,68,64]]) # 15 16 Y3C
M.append([[27,47],[37,57],[28,48],[38,58],[29,49],[39,59],[61,69],[63,67],[62,68],[66,64]]) # 16 17 Y3D
M.append([[27,57,47,37],[28,58,48,38],[29,59,49,39],[61,67,69,63],[62,64,68,66]]) # 17 18 Y3O
# Z
M.append([[23,61,47,19],[26,62,44,18],[29,63,41,17],[31,37,39,33],[32,34,38,36]]) # 18 19 Z1C
M.append([[23,47],[61,19],[26,44],[62,18],[29,41],[63,17],[31,39],[37,33],[32,38],[34,36]]) # 19 20 Z1D
M.append([[23,19,47,61],[26,18,44,62],[29,17,41,63],[31,33,39,37],[32,36,38,34]]) # 20 21 Z1O
M.append([[22,64,48,16],[25,65,45,15],[28,66,42,14]]) # 21 22 Z2C
#M.append([[23,19,47,61],[26,18,44,62],[29,17,41,63],[31,33,39,37],[32,36,38,34],
#[21,13,49,67],[24,12,46,68],[27,11,43,69],[51,57,59,53],[52,54,58,56]]) # 21 22 Z2C = Z1O + Z3O
M.append([[22,48],[64,16],[25,45],[65,15],[28,42],[66,14]]) # 22 23 Z2D
#M.append([[23,47],[61,19],[26,44],[62,18],[29,41],[63,17],[31,39],[37,33],[32,38],[34,36],
#[21,49],[67,13],[24,46],[68,12],[27,43],[69,11],[51,59],[53,57],[52,58],[56,54]]) # 22 23 Z2D = Z1D + Z3D
M.append([[22,16,48,64],[25,15,45,65],[28,14,42,66]]) # 23 24 Z2O
#M.append([[23,61,47,19],[26,62,44,18],[29,63,41,17],[31,37,39,33],[32,34,38,36],
#[21,67,49,13],[24,68,46,12],[27,69,43,11],[51,53,59,57],[52,56,58,54]]) # 23 24 Z2O = Z1C + Z3C
M.append([[21,67,49,13],[24,68,46,12],[27,69,43,11],[51,53,59,57],[52,56,58,54]]) # 24 25 Z3C
M.append([[21,49],[67,13],[24,46],[68,12],[27,43],[69,11],[51,59],[53,57],[52,58],[56,54]]) # 25 26 Z3D
M.append([[21,13,49,67],[24,12,46,68],[27,11,43,69],[51,57,59,53],[52,54,58,56]]) # 26 27 Z3O
# Список объединеннных движений
# Изначально пустой и заполняется отдельной функцией
# Итоговый размер 27*27
MM=[]
# Функция первоначальной инициализации кубика
# Заполняется список C указанными выше значениями (11-19, 21-29,...,61-69)
# Перед повторной инициализацией необходимо пересоздать C
def init():
    for i in range(6): # Число элементов списка C
        for j in range(3): # Добавляем 3 списка по 3 элемента в каждом - получается грань 3х3
            C[i].append([(i+1)*10+j*3+1,(i+1)*10+j*3+2,(i+1)*10+j*3+3])
# Функция инициализации списка объединенных движений
# Получается 729 элементов
def init_merge():
    for i in range(len(M)):
        for j in range(len(M)):
            MM.append(merge(i,j))
# Функция анализа текущего состояния кубика
# Параметр t - тип действия 
#          0 - вывод на экран списков aI и aO; 
#          1 - посчитать какое число квадратов находится на своих местах (для собранного это 54)
#          Иное - вернуть два этих списка
# Список aI - список из 54 элеменов, обозначающий квадраты 11-19 21-29 ... 61-69 
# Список aO - список из 54 элеменов, соотносящийся с aI. Какой квадрат установлен
# Например aI[0] всегда 11, а если aO[0] = 38, это значит, что на месте квадрата 11 находится квадрат 38
# Если aI[0] = aO[0], это значит, что квадрата 11 не поменял свое расположение
def analyse(t):
    aI=[]
    aO=[]
    for s in range(6):
        for j in range(3):
            for k in range(3):
                aI.append((s+1)*10+j*3+k+1)
                aO.append(C[s][j][k])
    if t==0:            
        print(aI)
        print(aO)
    elif t==1:
        ret=0
        for j in range(54):
            if aI[j] == aO[j]:
                ret+=1
        return(ret)
    else:
        return(aI,aO) 
# Функция анализа обратного состояния кубика
# Обратное - это перевернутое текущее
# Параметр t - тип действия 
#          0 - вывод на экран списков aI и aOB
#          1 - построить для обратного состояния план перемещений, аналогичный элементу списка M
#          Иное - вернуть два этих списка
# Параметр t2 - тип дополнительного действия для t=1
#          0 - вывод на экран плана перемещений mB 
#          1 - вернуть план перемещений
#          Иное - вернуть число квадратов, расположенных не на своих местах
# Список aOB строится на основе списка aO функции analyse
#   Например, если aI[0]=11, aI[1]=12, aO[0]=12, то aOB[1]=11
#   Если на месте квадрата 11 стоит квадрат 12, то в обратном списке на месте квадрата 12 стоит 11
# План перемещений mB - список списков в котором указаны циклы перемещения квадратов на основе обратного списка
def analyseB(t,t2):
    aI,aO=analyse(2)
    aOB=[0]*len(aI) # Инициализация обратного списка вначале нулями
    for j in range(len(aI)):
        k=aI.index(aO[j])
        aOB[k]=aI[j]
    if t==0:            
        print(aI)
        print(aOB)
    elif t==1:
        mB=[] # Инициализация плана перемещений
        for j in range(len(aOB)):
            k=1
            if aOB[j]!=aI[j]: # В план перемещений попадают только те квадраты, которые не на своих местах
                k=indArr(mB,aOB[j]) # Если 0, то квадрат не в плане перемещений
            if k==0:
                    aM=get_move(aOB[j],aI,aOB) # Для квадрата построить план перемещений 
                    mB.append(aM) # добавить построенный план в список
        if t2==0:
            print(mB)
        elif t2==1:
            return(mB)
        else:
            return(len(split(mB,1)))
    else:
        return(aI,aOB)       
# Фуннкция дополнения плана перемещения обратного состояния для последующего анализа
# Параметр op - плана перемещения обратного состояния (analyseB(1,1))
# Возвращается тот же план перемещения, но где каждый список дополняется
# Если список из 2 и более - в конец перемещения добавляется 0-ой элемент
# Если список из 3 и более - в конец перемещения добавляется еще и 1-ой элемент
# Если список из 2 и более - в конец перемещения добавляется еще и 2-ой элемент
# Такой расширенный план нужен, чтобы в нем искать элементы из списка M
def back2analyse(op):
    ra=[]
    for ai in op:
        ra.append([])
        for i in ai:
            ra[-1].append(i)
        ra[-1].append(ra[-1][0])    
        if len(ai)>=3:
            ra[-1].append(ra[-1][1])    
        if len(ai)>=4:
            ra[-1].append(ra[-1][2])    
    return(ra)             
# Фуннкция поиска в плане перемещений какого-то движения
# Параметры aB - расширенный план перемещения обратного состояния
#           i - номер движения из списка M
# Возвращается список из 3 элементов - число перемещений из 2, 3 и 4
# Например число перемещений из 2 - это если в [1,2,3,4,5] есть [3,4]
#          число перемещений из 3 - это если в [1,2,3,4,5] есть [2,3,4]
#          число перемещений из 4 - это если в [1,2,3,4,5] есть [2,3,4,5]
def analyseIN(aB,i):
    a=[0,0,0]
    ar=split_full(M[i],1)
    for j in aB:
        for k in range(len(j)):
            if j[k:k+1] in ar: # перемещения из 2
                a[0]+=1
            if j[k:k+2] in ar: # перемещения из 3
                a[1]+=1
            if j[k:k+3] in ar: # пермещения из 4
                a[2]+=1
    return(a)
# Функция поиска в списке нужного значения (в том числе, если в списке списков ищется список)
# Параметр a - список, в котором ищем
#          k - что ищем
# Возвращаем номер элемента, начинающийся с 1 или 0, если не нашли
def indArr(a,k):
    for i in range(len(a)):
        if k in a[i]:
            return(i+1)
    return(0)  
# Функция построения цепочки перемещений по паре списков состояния
# Параметр  k - номер квадрата, с которого начинаем построение цепочки
#           ai - список порядковых номеров квадратов
#           ao - список состояний квадратов
# Строит цеплчку движения, начиная с k
def get_move(k,ai,ao): 
    m=[k] # Первый элемент в цепочке всегда k
    r=0
    while r!=k:
        i=ai.index(m[-1]) # Получаем индекс последнего элемента в цепочке
        r=ao[i] # Получаем квадрат по этому индексу
        if r!=k: # Если цепочка не замкнулась добавляем в него квадрат
            m.append(ao[i])
    return(m)      
# Функция ищет в последовательности для обратного лучшее движение из направления
# Возвращает один из элементов списка N
# Параметр  aB - последовательнсть сборки для обратного - список списков
#           xx - направление движения, например X2 или Y1
def compareXX(aB,xx):
    #print('ab',aB)
    #print('xx',xx)
    #print(N[xx*3][0:2])
    a1=split2(aB,1)
    #print('a1',a1)
    mm=0
    nn=''
    #print('mm,nn',mm,nn)
    for i in range(3):
        r=0
        #print('i',i)
        #print('NN',N[xx*3+i])
        #print('MM',M[xx*3+i])
        a2=split2(M[xx*3+i],1)
        #print('a2',a2)
        for k in a2:
            if k in a1:
                r+=1    
        #print('r',r)
        if r>mm:
            nn=N[xx*3+i]
            mm=r
            #print('mm,nn',mm,nn)
    #print('nn',nn)        
    return(nn)            
# Функция деления движения на пары (формула 5) 
# Параметр  am - движение, список списков,например одно из M
#           t - действие (0 - печатать результат, иначе - вернуть)
# Получается список пар из движения, причем каждая пара сортируется
# Например, для [13,33,63,57] получаем [[13,33],[33,63],[57,63]]
def split(am,t):
    ar=[]
    for ai in am:
        rai=rotate(ai)
        for i in range(len(rai)-1):
            ar.append(minmax(rai[i],rai[i+1]))
    if t==0:
        print(ar)
    else:
        return(ar) 
# Функция деления движения на пары, аналогичная split 
# Параметр  am - движение, список списков, например одно из M
#           t - действие (0 - печатать результат, иначе - вернуть)
# Получается список пар из движения, причем каждая пара сортируется
# В отличие от split добавляется связь первого и последнего
# Например, для [13,33,63,57] получаем [[13,33],[33,63],[57,63],[13,57]]
def split2(am,t):
    ar=[]
    for ai in am:
        rai=rotate(ai)
        for i in range(len(rai)-1):
            ar.append(minmax(rai[i],rai[i+1]))
        if len(ai)>2:    
            ar.append(minmax(ai[0],ai[-1]))
    if t==0:
        print(ar)
    else:
        return(ar) 
# Функция деления движения на пары, аналогичная split 
# Параметр  am - движение, простой список
#           t - действие (0 - печатать результат, иначе - вернуть)
# Получается список пар из списка, причем каждая пара сортируется
# В отличие от split на вход попадает простой список, а не список списков
# Перед началом деления в конец am добавляется 0-ой элемент
def split_into2(am,t):
    ar=[]
    rai=rotate(am)
    rai.append(rai[0])
    for i in range(len(rai)-1):
        ar.append(minmax(rai[i],rai[i+1]))
    if t==0:
        print(ar)
    else:
        return(ar)
# Функция деления движения на тройки, аналогичная split_into2 
# Параметр  am - движение, простой список
#           t - действие (0 - печатать результат, иначе - вернуть)
# Получается список троек из списка, причем каждая тройка сортируется
# Перед началом деления в конец am добавляется 0-ой и 1-ый элементы               
def split_into3(am,t):
    ar=[]
    rai=rotate(am)
    rai.append(rai[0])
    rai.append(rai[1])
    for i in range(len(rai)-2):
        ar.append(rotate([rai[i],rai[i+1],rai[i+2]]))
    if t==0:
        print(ar)
    else:
        return(ar)         
# Функция деления движения на пары, тройки и четверки (что-то типа формулы 4) 
# Параметр  am - движение, список списков,например одно из M
#           t - действие (0 - печатать результат, иначе - вернуть)
# Получается список различных вариантов из движения, причем каждый вариант сортируется
# Например, для [13,33,63,57] получаем 
# [[13,33,63,57],[13,33,63],[33,63,57],[13,63,57],[13,33,57],[13,33],[33,63],[57,63],[13,57]]
def split_full(am,t):
    ar=[]
    for ai in am:
        ar.append(rotate(ai))
        if len(ai)==4:
            ra2=split_into2(ai,1)
            ra3=split_into3(ai,1)
            for aa in ra3:
                ar.append(rotate(aa))
            for aa in ra2:
                ar.append(rotate(aa))                
    if t==0:
        print(ar)
    else:
        return(ar) 
# Функция объдинения двух движений
# Параметры i1 и i2 - номера движений из списка M
# Возвращается движение, полученное из последовательного выполнения M[i1] и M[i2]
# Последовательность движений важна, так как M[i1] + M[i2] != M[i2] и M[i1]
def merge(i1,i2):
    i=[11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,
       41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68,69]
    o=[11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,
       41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68,69]
    l=[i1,i2]
    for j in l:
        m=split(M[j],1)
        for m2 in m:
            f=i.index(m2[0])
            s=i.index(m2[1])
            o[f],o[s] = o[s],o[f]
    oB=[0]*54
    for j in range(54):
        k=i.index(o[j])
        oB[j]=i[k]
    mB=[]
    for j in range(len(oB)):
        k=1
        if oB[j]!=i[j]:
            k=indArr(mB,oB[j])
        if k==0:
            aM=get_move(oB[j],i,oB)
            mB.append(aM)
    return(mB) 
# Функция объдинения 2 любых движения
# Параметры am1 и am2 - движений, в том числе и мерджи
# Возвращается движение, полученное из последовательного выполнения 1 и 2 движений
def merge2(am1,am2):
    i=[11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,
       41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68,69]
    o=[11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,
       41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68,69]
    l=[am1,am2]
    for j in l:
        m=split(j,1)
        for m2 in m:
            f=i.index(m2[0])
            s=i.index(m2[1])
            o[f],o[s] = o[s],o[f]
    oB=[0]*54
    for j in range(54):
        k=i.index(o[j])
        oB[j]=i[k]
    mB=[]
    for j in range(len(oB)):
        k=1
        if oB[j]!=i[j]:
            k=indArr(mB,oB[j])
        if k==0:
            aM=get_move(oB[j],i,oB)
            mB.append(aM)
    return(mB) 
# Функция по списку индексов движений мержит их в одно и возвращает итоговое движение
# Параметр aI - список индексов движений
def mergeM(aI):
    ar=M[aI[0]]
    for j in range(1,len(aI)):
        ar = merge2(ar,M[aI[j]])
    return(ar)    
# Функция псевдо-сортировки последовательности перемещений
# Параметр a - движение, простой Список
# Например, для [33,63,57,12] получаем [12,33,63,57]
def rotate(a):
#    if len(a)==2: # Список из 2 элементов не сортируем. Похоже так правильнее
#        return(a) 
    r=[]
    m=a.index(min(a)) # Находим минимальный элемент и будем его ставить первым
    for i in range(len(a)):
        r.append(a[m]) # Добавляем очередной элемент
        m+=1
        if m==len(a): # Если достигли конца списка - начинаем с начала
            m=0
    return(r)        
# Вспомогательная функция для получения отсортированного списка
# На вход передаются два числа
# На выходе список, где первым стоит минимальное из двух чисел
def minmax(f,s):
    if f>s:
        return([s,f])
    else:
        return([f,s]) 
# Функция анализа движения применительно к текущему состоянию
# Параметр  n - номер движения M
#           t - тип действия (0 - вывести на экран расширенную аналитику)
#                            (1 - вернуть число смежных пар)
#                            (2 - вернуть число улучшений и число ухудшений)
def analyseMforB(n,t):
    aM=split(M[n],1)
    aB=split(analyseB(1,1),1)
    r=0
    aR=[]
    for k in aM:
        if k in aB:
            aR.append(k)
            r+=1
    aM_2=split2(M[n],1)
    aB_2=split2(analyseB(1,1),1)
    r2=0
    aR2=[]
    for k in aM_2:
        if k in aB_2:
            aR2.append(k)
            r2+=1
    aGb,aBb = dots_before()
    aGa,aBa = dots_after(aM)
    aG1=[]
    aG2=[]
    aB1=[]
    aB2=[]
    for j1 in aGa:
        if j1 in aGb:
            aG1.append(j1)
        else:
            aG2.append(j1)
    for j1 in aBa:
        if j1 in aBb:
            aB1.append(j1)
        else:
            aB2.append(j1)
    if t==0:            
        print('Выбрано',N[n])
        print('Движение',M[n])
        print('Обратное',analyseB(1,1))
        print()
        print('Движение (split)',aM)
        print('Обратное (split)',aB)
        print('Число смежных пар',r)   
        print('Список смежных пар',aR)          
        print()
        print('Движение (split2)',aM_2)
        print('Обратное (split2)',aB_2)
        print('Число смежных пар',r2)   
        print('Список смежных пар',aR2)
        print()
        print('Установленные точки до изменения',aGb)
        print('Не установленные точки до изменения',aBb)
        print('Установленные точки после изменения',aGa)
        print('Не установленные точки после изменения',aBa)
        print('После изменения')
        print('Установленные остаются',aG1)
        print('Не установленные остаются',aB1)
        print('Установленные добавляются',aG2)
        print('Не установленные новые',aB2)
        print()
        print('Улучшение',len(aG2))
        print('Ухудшение',len(aB2))
        print()
        print('Число циклов в обратном',len(analyseB(1,1))) 
    elif t==1:
        return(r)
    elif t==2:
        return(len(aG2),len(aB2))
# Функция анализа движения применительно к текущему состоянию
# Улучшенная, но сильно сокращенная версия analyseMforB
# Параметр  am - любое движение, в том числе merge
# Возвращает число улучшений и число ухудшений
def analyseMforBplus(am):
    aM=split(am,1)
    aGb,aBb = dots_before()
    aGa,aBa = dots_after(aM)
    g=0
    b=0
    for j1 in aGa:
        if j1 not in aGb:
            g+=1
    for j1 in aBa:
        if j1 not in aBb:
            b+=1
    return(g,b) 
# Функция по текущему состоянию возвращает два списка
# aG - точки на своих местах
# aB - точки смещеные
def dots_before():
    i,o=analyse(2)
 
    aG=[]
    aB=[]
    for j in range(len(i)):
        if i[j]==o[j]:
            aG.append(i[j])
        else:
            aB.append(o[j])
    return(aG,aB)         
# Функция после применения движения возвращает два списка
# aG - точки на своих местах
# aB - точки смещеные
# Параметр aM - движение
def dots_after(aM):
    i,o=analyse(2)  
    aG=[]
    aB=[]
    for k in aM:
        f=i.index(k[0])
        s=i.index(k[1])
        o[f],o[s] = o[s],o[f]
    for j in range(len(i)):
        if i[j]==o[j]:
            aG.append(i[j])
        else:
            aB.append(o[j])
    return(aG,aB)         
# Функция анализа пары движений применительно к текущему состоянию
# Параметр  f - номер первого движения M
#           s - номер второго движения M 
# Вначале происходит объединение двух движений в последовательности первое+второе
# А затем строится последовательность перемещений для обратного состояния 
# Обе последовательности разбиваются на пары движения и сравниваются
# Возвращается число общих пар
def analyseMforB2(f,s):
    aM=split(merge(f,s),1)
    aB=split(analyseB(1,1),1)
    r=0
    for k in aM:
        if k in aB:
            r+=1
    return(r) 
# Функция анализа движения применительно к текущему состоянию
# Устаревшая и оставлена пока для истории
# Параметр  n - номер движения M
#           t - тип действия (0 - вывести на экран состояния)
#                            (1 - вернуть число улучшения/ухудшения)
#                            (2 - вернуть состояния)        
def analyseM(n,t):
    i=[11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,
       41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68,69]
    o=[11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,
       41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68,69]
    for j in M[n]:
        for k in range(len(j)-1):
            f=i.index(j[k])
            o[f]=j[k+1]
        f=i.index(j[len(j)-1])
        o[f]=j[0]
    im=[]
    om=[]
    for j in range(len(i)):
        if i[j] != o[j]:
            im.append(i[j])
            om.append(o[j])
    if t==0:            
        print(i)
        print(o)
        print(im)
        print(om)
    elif t==1:
        ret=0
        ii,oo=analyse(2)
        for j in range(len(im)):
            d1=ii.index(im[j])
            d2=ii.index(om[j])
            if ii[d1]==oo[d1]:
                ret-=1
            elif ii[d1]==oo[d2]:
                ret+=1
        return(ret)
    else:
        return(i,o)
# Функция анализа движения analyseM, но слегка модифицированная
# Возможно, что она не работает - не проверялась
# Устаревшая и оставлена пока для истории
def analyseM2(n,t):
    i=[]
    o=[]
    for j in M[n]:
        for k in range(len(j)-1):
            i.append(j[k])
            o.append(j[k+1])
        i.append(j[len(j)-1])
        o.append(j[0])    
    if t==0:            
        print(i)
        print(o)
    else:
        ret=0
        ii,oo=analyse(2)
        for j in range(len(i)):
            d1=ii.index(i[j])
            d2=ii.index(o[j])
            if ii[d1]==oo[d1]:
                ret-=1
            elif ii[d1]==oo[d2]:
                ret+=1
        return(ret)
# Функция в зависимости от значения массива С красит кубик 
def color (Label):
    a = Label.cget("text")
    if a//10 == 1 :
        Label.config(background = "white")
    if a//10 == 2 :
        Label.config(background = "orange")  
    if a//10 == 3 :
        Label.config(background = "green")  
    if a//10 == 4 :
        Label.config(background = "red")  
    if a//10 == 5 :
        Label.config(background = "blue") 
        Label.config(foreground = "white")
    if a//10 == 6 :
        Label.config(background = "yellow")
        Label.config(foreground = "black")     
# Функция выводит на экран развернутый кубик
# В качестве квадратов выводятся числа из списка C
# Это текущее состояние кубика.
def print_cube():
    for i in range(3):
        print("            ",C[0][i])
    for i in range(3):
        print(C[1][i],C[2][i],C[3][i],C[4][i])
    for i in range(3):
        print("            ",C[5][i])
    print()
    # белый
    lbl11 = Label(window,text=C[0][0][0], background="white")
    lbl12 = Label(window,text=C[0][0][1], background="white")
    lbl13 = Label(window,text=C[0][0][2], background="white")
    lbl14 = Label(window,text=C[0][1][0], background="white")
    lbl15 = Label(window,text=C[0][1][1], background="white")
    lbl16 = Label(window,text=C[0][1][2], background="white")
    lbl17 = Label(window,text=C[0][2][0], background="white")
    lbl18 = Label(window,text=C[0][2][1], background="white")
    lbl19 = Label(window,text=C[0][2][2], background="white")
    color(lbl11)
    color(lbl12)
    color(lbl13)
    color(lbl14)
    color(lbl15)
    color(lbl16)
    color(lbl17)
    color(lbl18)
    color(lbl19)
    lbl11.grid(row=1 , column=4)
    lbl12.grid(row=1 , column=5)
    lbl13.grid(row=1 , column=6)
    lbl14.grid(row=2 , column=4)
    lbl15.grid(row=2 , column=5)
    lbl16.grid(row=2 , column=6)
    lbl17.grid(row=3 , column=4)
    lbl18.grid(row=3 , column=5)
    lbl19.grid(row=3 , column=6)
    # оранжевый
    lbl21 = Label(window,text=C[1][0][0], background="orange")
    lbl22 = Label(window,text=C[1][0][1], background="orange")
    lbl23 = Label(window,text=C[1][0][2], background="orange")
    lbl24 = Label(window,text=C[1][1][0], background="orange")
    lbl25 = Label(window,text=C[1][1][1], background="orange")
    lbl26 = Label(window,text=C[1][1][2], background="orange")
    lbl27 = Label(window,text=C[1][2][0], background="orange")
    lbl28 = Label(window,text=C[1][2][1], background="orange")
    lbl29 = Label(window,text=C[1][2][2], background="orange")
    color(lbl21)
    color(lbl22)
    color(lbl23)
    color(lbl24)
    color(lbl25)
    color(lbl26)
    color(lbl27)
    color(lbl28)
    color(lbl29)
    lbl21.grid(row=4 , column=1)
    lbl22.grid(row=4 , column=2)
    lbl23.grid(row=4 , column=3)
    lbl24.grid(row=5 , column=1)
    lbl25.grid(row=5 , column=2)
    lbl26.grid(row=5 , column=3)
    lbl27.grid(row=6 , column=1)
    lbl28.grid(row=6 , column=2)
    lbl29.grid(row=6 , column=3)
    # зеленый
    lbl31 = Label(window,text=C[2][0][0], background="green")
    lbl32 = Label(window,text=C[2][0][1], background="green")
    lbl33 = Label(window,text=C[2][0][2], background="green")
    lbl34 = Label(window,text=C[2][1][0], background="green")
    lbl35 = Label(window,text=C[2][1][1], background="green")
    lbl36 = Label(window,text=C[2][1][2], background="green")
    lbl37 = Label(window,text=C[2][2][0], background="green")
    lbl38 = Label(window,text=C[2][2][1], background="green")
    lbl39 = Label(window,text=C[2][2][2], background="green")
    color(lbl31)
    color(lbl32)
    color(lbl33)
    color(lbl34)
    color(lbl35)
    color(lbl36)
    color(lbl37)
    color(lbl38)
    color(lbl39)
    lbl31.grid(row=4 , column=4)
    lbl32.grid(row=4 , column=5)
    lbl33.grid(row=4 , column=6)
    lbl34.grid(row=5 , column=4)
    lbl35.grid(row=5 , column=5)
    lbl36.grid(row=5 , column=6)
    lbl37.grid(row=6 , column=4)
    lbl38.grid(row=6 , column=5)
    lbl39.grid(row=6 , column=6)
    # красный
    lbl41 = Label(window,text=C[3][0][0], background="red")
    lbl42 = Label(window,text=C[3][0][1], background="red")
    lbl43 = Label(window,text=C[3][0][2], background="red")
    lbl44 = Label(window,text=C[3][1][0], background="red")
    lbl45 = Label(window,text=C[3][1][1], background="red")
    lbl46 = Label(window,text=C[3][1][2], background="red")
    lbl47 = Label(window,text=C[3][2][0], background="red")
    lbl48 = Label(window,text=C[3][2][1], background="red")
    lbl49 = Label(window,text=C[3][2][2], background="red")
    color(lbl41)
    color(lbl42)
    color(lbl43)
    color(lbl44)
    color(lbl45)
    color(lbl46)
    color(lbl47)
    color(lbl48)
    color(lbl49)
    lbl41.grid(row=4 , column=7)
    lbl42.grid(row=4 , column=8)
    lbl43.grid(row=4 , column=9)
    lbl44.grid(row=5 , column=7)
    lbl45.grid(row=5 , column=8)
    lbl46.grid(row=5 , column=9)
    lbl47.grid(row=6 , column=7)
    lbl48.grid(row=6 , column=8)
    lbl49.grid(row=6 , column=9)
    # синий
    lbl51 = Label(window,text=C[4][0][0], background="blue")
    lbl52 = Label(window,text=C[4][0][1], background="blue")
    lbl53 = Label(window,text=C[4][0][2], background="blue")
    lbl54 = Label(window,text=C[4][1][0], background="blue")
    lbl55 = Label(window,text=C[4][1][1], background="blue")
    lbl56 = Label(window,text=C[4][1][2], background="blue")
    lbl57 = Label(window,text=C[4][2][0], background="blue")
    lbl58 = Label(window,text=C[4][2][1], background="blue")
    lbl59 = Label(window,text=C[4][2][2], background="blue")
    color(lbl51)
    color(lbl52)
    color(lbl53)
    color(lbl54)
    color(lbl55)
    color(lbl56)
    color(lbl57)
    color(lbl58)
    color(lbl59)
    lbl51.grid(row=4 , column=10)
    lbl52.grid(row=4 , column=11)
    lbl53.grid(row=4 , column=12)
    lbl54.grid(row=5 , column=10)
    lbl55.grid(row=5 , column=11)
    lbl56.grid(row=5 , column=12)
    lbl57.grid(row=6 , column=10)
    lbl58.grid(row=6 , column=11)
    lbl59.grid(row=6 , column=12)
    # желтый
    lbl61 = Label(window,text=C[5][0][0], background="yellow", foreground="black")
    lbl62 = Label(window,text=C[5][0][1], background="yellow", foreground="black")
    lbl63 = Label(window,text=C[5][0][2], background="yellow", foreground="black")
    lbl64 = Label(window,text=C[5][1][0], background="yellow", foreground="black")
    lbl65 = Label(window,text=C[5][1][1], background="yellow", foreground="black")
    lbl66 = Label(window,text=C[5][1][2], background="yellow", foreground="black")
    lbl67 = Label(window,text=C[5][2][0], background="yellow", foreground="black")
    lbl68 = Label(window,text=C[5][2][1], background="yellow", foreground="black")
    lbl69 = Label(window,text=C[5][2][2], background="yellow", foreground="black")
    color(lbl61)
    color(lbl62)
    color(lbl63)
    color(lbl64)
    color(lbl65)
    color(lbl66)
    color(lbl67)
    color(lbl68)
    color(lbl69)
    lbl61.grid(row=7 , column=4)
    lbl62.grid(row=7 , column=5)
    lbl63.grid(row=7 , column=6)
    lbl64.grid(row=8 , column=4)
    lbl65.grid(row=8 , column=5)
    lbl66.grid(row=8 , column=6)
    lbl67.grid(row=9 , column=4)
    lbl68.grid(row=9 , column=5)
    lbl69.grid(row=9 , column=6)
# Функция выводит на экран развернутый кубик
# В качестве квадратов выводятся буква цвета 
# Это текущее состояние кубика.
def print_cubeC():
    print_cube()
    color='БОЗКСЖ' # Соответствует ULFRBD  
    for i in range(3):
        s=''
        for j in range(3):
            ic=C[0][i][j]//10-1
            s=s+color[ic]+' '
        print("     ",s)
    for i in range(3):
        s=''
        for k in range(1,5):
            for j in range(3):
                ic=C[k][i][j]//10-1
                s=s+color[ic]+' '
        print(s)
    for i in range(3):
        s=''
        for j in range(3):
            ic=C[5][i][j]//10-1
            s=s+color[ic]+' '
        print("     ",s)
    print() 
# Функция разбивает движение на задействованные точки и возвращает список точек в отсортированном виде
# Параметр a - движение М
def dotsin(a):
    r=[]
    for i in a:
        for j in i:
            r.append(j)
    r.sort()
    return(r)
# Функция сравнивает точки в двух движениях
# Параметры a1 и a2 - списки точек
#           t - выбор действия
#           0 - Возвращает число общих точек в списках
#           1 - Возвращает список общих точек в списках
#           2 - Возвращает список точек в a2, которых нет в a1
#           3 - Возвращает список точек в a1, которых нет в a2
def dotscompare(a1,a2,t):
    a=[]
    if t==3:
        for i in a1:
            if i not in a2:
                a.append(i)        
    else:    
        for i in a2:
            if i in a1 and t in [0,1]:
                a.append(i)
            elif i not in a1 and t==2:
                a.append(i)
    if t==0:
        return(len(a))  
    else:
        return(a)
# Функция, которая выполняет сборку/разборку кубика по заданной последовательности команж
# Параметр line - строка, в которой одна или несколько команд N, разделенных пробелами
def do_do(line):
    a = list(line.split())
    for i in a:
        command(i)
# Функция применяет к текущему состоянию кубика заданное движение
# Параметр c - команда из списка N
# За основу берется текущее состояние C, к которму применяется переданная команда
# В результате состояние C изменяется
def command(c):
    ind=N.index(c)
    m=M[ind]
    for i in m:
        old=get(i[0]) # Сохраняем первый квадрат в цепочке
        for j in range(len(i)-1):
            move(i[j],i[j+1]) # Перемещаем налево по цепочке
        put(i[len(i)-1],old) # Пишем первый на место последнего
# Функция вычитывает какой квадрат находится в нужной позиции и возвращает его
# Параметр e - Номер квадрата в раскладке собранного кубика (11-19,...61-69)
# Ищет нужный квадрат и возвращает какое начение в нем сейчас
def get(e):
    f=int(str(e)[0])
    s=int(str(e)[1])
    a=(s-1)//3
    b=(s-1)%3
    ret=C[f-1][a][b]
    return(ret) 
# Функция пишет в нужный квадрат переданное значение
# Параметр  e - номер квадрата для записи
#           o - записываемое значение
def put(e,o):
    f=int(str(e)[0])
    s=int(str(e)[1])
    a=(s-1)//3
    b=(s-1)%3
    C[f-1][a][b]=o 
# Функция пишет в нужный квадрат значение другого квадрата
# Параметр  e1 - номер квадрата для записи
#           e1 - номер квадрата для чтения
def move(e1,e2):
    old=get(e2)
    put(e1,old) 
# Функция проверяет решен ли кубик
# Возвращает True,если собран, иначе - False
def issolved():
    ret=False
    if C[0]==[[11,12,13],[14,15,16],[17,18,19]]:
        if C[1]==[[21,22,23],[24,25,26],[27,28,29]]:
            if C[2]==[[31,32,33],[34,35,36],[37,38,39]]:
                if C[3]==[[41,42,43],[44,45,46],[47,48,49]]:
                    if C[4]==[[51,52,53],[54,55,56],[57,58,59]]:
                        if C[5]==[[61,62,63],[64,65,66],[67,68,69]]:
                            ret=True
    return(ret)
# Функция генерирует случайную последовательность движений для разборки кубика
# Одновременно генерируется последовательность для сборки, обратная разборке
# Параметр n - число ходов, насколько нужно разобрать кубика
# Возвращаются две строки, состоящие из команд списка N, разделенных пробелом
# m - строка разбора
# s - строка сборки
def random_mess(n):
    first='XYZ'
    second='123'
    third='CDO'
    m=''
    s=''
    random.seed()
    for i in range(n):
        r1 = random.randint(0,2)
        r2 = random.randint(0,2)
        r3 = random.randint(0,2)
        m = m + first[r1]+second[r2]+third[r3]+' '
        s = first[r1]+second[r2]+third[2-r3]+' '+s
    return m,s
# Функция ручной сборки
# В цикле вводятся команды и после каждой печатается раскладка текущего состояния кубика
def manual_solve():
    t='1'
    while t!='0':
        t=input('Введите команду или 0 для завершения:')
        if t!='0':
            do_do(t)
            print_cube() 
# Функция автоматической сборки
# Параметр m - число шагов для сборки, после достижения которого работа остановится
# Также функция может завершить работу досрочно, если кубик будет собран
# Возвращает последовательность найденного решения
def auto_solve(m):
    solv=''
    n=m
    while m!=0:
        print('Шаг',n-m+1)
        r1=analyse(1)
        if r1==54:
            break
        else:
            bi=findbest(0)
            solv=solv+N[bi]+' '
            do_do(N[bi]) 
        m-=1    
    print('Предполагаемое решение')
    print(solv)
# Функция полуавтоматической сборки
# Параметр m - число шагов для сборки, после достижения которого работа остановится
# Также функция может завершить работу досрочно, если кубик будет собран
# На каждом шаге предлагает свои решения и позволяет их принять или ввести свой ход
# Возвращает последовательность найденного решения    
def auto_solve2(m):
    global Bl # Номер хода, который нужно заблокировать. Применяется, чтобы после движения не делалось обратное
    global solv    
    solv=''
    n=m
    Bl=-1
    #l4=True # Пакет 4 включен
    l4=False # Пакет 4 выключен
    r4='Отключен'
    tPrev=''
    while m!=0:
        if n==m:
            if l4:
                print('Пакет 4 включен и потенциально работает долго. Для отключения введите 4')
            else:
                print('Пакет 4 выключен, так как потенциально работает долго. Для включения введите 4')
        iif=input('Нажмите Enter для продолжения...') # Пауза для прочтения результатов очередного хода
        if iif=='4':
            l4=not l4
        print('Шаг',n-m+1)
        r1=analyse(1)
        if r1==54: # Если собрано - выходим
            break
        else:
            var=[]
            r0=analyse0(0)               # Запуск нулевого пакета анализа
            r1=analyse1(0)               # Запуск первого пакета анализа
            var.append([r1[0],-1])
            var.append(analyse2())       # Запуск второго пакета анализа
            var.append(analyse3(0))      # Запуск третьего пакета анализа
            if l4:
                r4=analyse4(1,0)         # Запуск четвертого пакета анализа
            
            # Для ограничения анализа 4 делаем составление списка кандидатов
            a5=[]
            for i in r0:
                if i not in a5:
                    a5.append(i)
            for i in var[2]:
                if i not in a5:
                    a5.append(i)
            s1=''        
            for i in r1:
                s1+=N[i]+' '
                if N[i] not in a5:
                    a5.append(N[i])
            if N[var[1][0]] not in a5:
                    a5.append(N[var[1][0]]) 
            if var[1][1]!=-1 and N[var[1][1]] not in a5:
                    a5.append(N[var[1][1]])
            r42=analyse4(1,0,a5)        # Запуск четвертого точечного пакета анализа
            r5=analyse5(2,0,a5,3)       # Запуск пятого пакета анализа                    
            print('Шаг',n-m+1)
            print_cube()
            print('Правильный сбор',solve) 
            print('Текущий    сбор',solv)
            print('Возможные решения:')
            if len(r0)!=0:
                print('Пакет 0 - ',r0)
            print('0 - Пакет 1 - ',N[var[0][0]]+' ( '+s1+')')
            if (N[var[0][0]] in r0 and N[var[0][0]]!=N[var[1][0]]):
                print('Пакет 1 совпадает с пакетом 0')
            if var[1][1]==-1:
                print('1 - Пакет 2 - ',N[var[1][0]])
            else: 
                print('1 - Пакет 2 - ',N[var[1][0]],' + ',N[var[1][1]])
            if (N[var[1][0]] in r0):
                print('Пакет 2 совпадает с пакетом 0')
            print('Пакет 3 - ',var[2])
            print('Пакет 4 - ',r4)
            print('2 - Пакет 4т - ',r42)
            print('3 - Пакет 5 - ',r5)
            if tPrev!='':
               print('5 - Предыдущая последовательность - ',tPrev) 
            # Вводим 4, если на следующий шаг нужно включить пакет 4
            # Выбираем из 1, 2, 4т и 5 пакетов анализа
            # или вводим свою команду в формате элемента списка N
            iif='4'
            while iif=='4':
                if l4:
                    print('4 - Отключить пакет 4')
                else:
                     print('4 - Включить пакет 4')
                iif=input('0/1/2/3 - Принимаем, иначе введите свое?')
                if iif=='4':
                    if l4:
                        l4=False
                    else:
                        l4=True
            bi=-1
            ci=-1
            Bl=-1
            if iif=='0':
                bi=var[0][0]
                ci=var[0][1]
                tPrev=''
            elif iif=='1':
                bi=var[1][0]
                ci=var[1][1]
                tPrev=''
            elif iif=='3':
                ci=-3
            elif iif=='5' and tPrev!='':
                ci=-5                
            elif iif in N:
                print('Данный шаг решаем вручную')
                bi=N.index(iif)
                tPrev=''
            else:
                ci =-2
            if ci==-1:
                print('Выбрали ',bi,'(',N[bi],')') # Применяем ход
                solv=solv+N[bi]+' '        
                do_do(N[bi])
                if N[bi][-1]=='D': # Анализируем ход и генерируем запрет как защиту от обратного
                    Bl=bi
                elif N[bi][-1]=='C':  
                    Bl=bi+2
                else:
                    Bl=bi-2   
            elif ci==-2:
                s4t=''
                bi=N.index(r42[-1])
                for i in r42:
                    s4t+=i+' '
                
                print('Выбрали последовательность из пакета 4т',s4t) # Применяем последовательность ходов
                if len(s4t)>4:
                   iif=input('1 - Для выбора только первого движения')
                   if iif=='1':
                       tPrev=s4t[4:]
                       s4t=s4t[0:3]
                       print('Выбрали',s4t)
                solv=solv+s4t        
                do_do(s4t)
                # Запрет обратого ходя для пакета 5 пока отключаем
                #if N[bi][-1]=='D': # Анализируем ход и генерируем запрет как защиту от обратного
                #    Bl=bi
                #elif N[bi][-1]=='C':  
                #    Bl=bi+2
                #else:
                #    Bl=bi-2   
            elif ci==-3:
                s5=''
                bi=N.index(r5[-1])
                for i in r5:
                    s5+=i+' '                
                print('Выбрали последовательность из пакета 5',s5) # Применяем последовательность ходов
                if len(s5)>4:
                   iif=input('1 - Для выбора только первого движения')
                   if iif=='1':
                       tPrev=s5[4:]
                       s5=s5[0:4]
                       print('Выбрали',s5)
                solv=solv+s5 
                do_do(s5)
                # Запрет обратого ходя для пакета 5
                #if N[bi][-1]=='D': # Анализируем ход и генерируем запрет как защиту от обратного
                #    Bl=bi
                #elif N[bi][-1]=='C':  
                #    Bl=bi+2
                #else:
                #    Bl=bi-2   
            elif ci==-5:
                print('Выбрали предыдущую последовательность',tPrev) # Применяем последовательность ходов
                s5=tPrev
                if len(s5)>4:
                   iif=input('1 - Для выбора только первого движения')
                   if iif=='1':
                       tPrev=s5[4:]
                       s5=s5[0:4]
                       print('Выбрали',s5)
                solv=solv+s5 
                do_do(s5)
                # Запрет обратого ходя для пакета 5
                #if N[bi][-1]=='D': # Анализируем ход и генерируем запрет как защиту от обратного
                #    Bl=bi
                #elif N[bi][-1]=='C':  
                #    Bl=bi+2
                #else:
                #    Bl=bi-2   
            else: # В случае, если пакет 2 вернул два хода - применяем их
                print('Выбрали ',bi,'(',N[bi],')+',ci,'(',N[ci],')')
                solv=solv+N[bi]+' '+N[ci]+' '        
                do_do(N[bi]+' '+N[ci])
        m-=1    
    print('Предполагаемое решение')
    print(solv)    
# Функция поиска оптимального хода от текущего состояния
# Параметр t -  0 - поиск для одного хода
#               1 - поиск для двух ходов
# Устарела и не используется. Оставлена для истории
def findbest(t):
    b=-100
    bi=-1
    for i in range(len(M)):
        if t==0:
            r2=analyseM(i,1)
        else:
            r2=analyseMforB(i,1)
            print('Движение',N[i],'имеет',r2,'общих точек')
            if r2>b:
                b=r2
                bi=i
    return(bi) 
# Пакет анализа 0
# Имеет смысл, если включены прямые повороты вторых рядов
# Нужно доработать для возврата точного результата
# Также нужно оптимизировать анализ, избавившись от r или сильно его уменьшить
# Ищет сколько центральных точек в каждой грани на своих местах и как их нужно перемещать
# Параметр t - если равен 0, то выводим на экран статистику
# Возвращает возможные движения или [], если все ОК
def analyse0(t):
    ar=[]
    l='ULFRBD' # Кодовый символ грани
    m=['X2C','X2D','X2O','Y2C','Y2D','Y2O','Z2C','Z2D','Z2O']
    c=[0]*9
    r=[[[],['Z2O'],['X2O'],['Z2C'],['X2C'],['Z2D','X2D']], # Настройки движений для поворота центра
    [['Z2C'],[],['Y2O'],['Z2D','Y2D'],['Y2C'],['Z2O']],
    [['X2C'],['Y2C'],[],['Y2O'],['X2D','Y2D'],['X2O']],
    [['Z2O'],['Z2D','Y2D'],['Y2C'],[],['Y2O'],['Z2C']],
    [['X2O'],['Y2O'],['X2D','Y2D'],['Y2C'],[],['X2C']],
    [['Z2D','X2D'],['Z2C'],['X2C'],['Z2O'],['X2O'],[]]]
    for i in range(6):
        print('Грань ',l[i],'должна быть',(i+1)*10+5,', равна ',C[i][1][1])
        d=(C[i][1][1]//10)-1
 
        if len(r[i][d])==0:
            print('OK')
        else:    
            print('Рекомендуется ',r[i][d])
            if len(r[i][d])==2:
                j=m.index(r[i][d][1])
                c[j]+=1
            if len(r[i][d])>=1:
                j=m.index(r[i][d][0])
                c[j]+=1
    j=max(c)
    if j!=0:
        for i in range(len(c)):
            if c[i]==j:
                ar.append(m[i])
    return(ar)                    
# Пакет анализа 1
# Смотрит сколько четверок, троек и двоек сможет закрыть каждое движение
# От этого расчитываются баллы умножением числа четверок на 4, троек на 3 и двоек на 2
# Дополнительно, без баллов, показываем сколько может быть улучшений/ухудшений
# Параметр  t - если равен 0, то выводим на экран статистику
#           n - число возвращаемых значений
# Возвращает список индексов наилучших движений 
def analyse1(t,n=3):
    oi=analyseB(1,2)
    if t==0:
        print('Осталось собрать',oi)
        print('Глубинный анализ')
    aBr=back2analyse(analyseB(1,1))
    aBest=[-1]*n
    aIB=[-1]*n
    best=-100
    ibest=-1
    gb=-100
    for i in range(len(M)):
        aMark=analyseIN(aBr,i)
        t1=4*aMark[2]+3*aMark[1]+2*aMark[0]
        if t1>0 or solve[len(solv):len(solv)+3]==N[i]:
            g,b=analyseMforB(i,2)
            fs=''
            if solve[len(solv):len(solv)+3]==N[i] and solv==solve[:len(solv)]:
               fs = 'Шаг из правильного сбора' 
            if t==0:
                print(N[i],' - 4:',aMark[2],', 3:',aMark[1],', 2:',aMark[0],' Total: ',t1,' points Good/Bad ',g,'/',b,' ',fs)
        m=min(aBest)
        im=aBest.index(m)
        if t1>m:
            aBest[im]=t1
            aIB[im]=i    
    m=max(aBest)
    im=aBest.index(m)
    if im!=0:
        aBest[0],aBest[im]=aBest[im],aBest[0]
        aIB[0],aIB[im]=aIB[im],aIB[0]
    if t==0:    
        print('Правильный сбор',solve) 
        print('Текущий    сбор',solv)
        print('Рекомендуемый шаг - ',N[aIB[0]])   
    return(aIB)
 
# Пакет анализа 2
# Анализирует пары и, если решение пройдет за два хода - возвращает оба
def analyse2():
    bi,ci=findbest2(6,1)
    return([bi,ci]) 
# Пакет анализа 3
# Возвращает список движений N, дающих наилучшие результаты
# Ищет сколько точек в каждом из движении и сравнивает с точками последовательности движений обратного состояния
# Параметр t - если равен 0, то выводим на экран статистику
#          n - минимальное число движений, которое нужно вернуть
def analyse3(t,n=5):
    ab=analyseB(1,1)
    adB=dotsin(ab)
    adM=[]
    aR0=[100]*9
    aR=[]
    if t==0:
        print('Анализ точек')
        print('Обратное')
        print('Решение',ab)
        print('Точки',len(adB),adB)
        print()
    for i in range(9):
        adM.append(dotsin(M[i*3]))
    for i in range(9):
        o=dotscompare(adB,adM[i],0)
        aOP=dotscompare(adB,adM[i],1)
        aOM=dotscompare(adB,adM[i],2)
        aOM2=dotscompare(adB,adM[i],3)
        a8=[]
        for j in range(9):
            if j!=i:
                a8.append(dotscompare(aOM2,adM[j],1))
            else:
                a8.append([])
        aR0[i]=len(aOM)
        if t==0:
            print("Движение",N[i*3][0:2])
            print('Точки',len(adM[i]),adM[i])
            print('Общих',o,aOP)
            print('Левых',len(aOM),aOM)
            print('Нет в обратном',len(aOM2),aOM2)
            for j in range(9):
                if j!=i:
                    print('       ',N[j*3][0:2],len(a8[j]),a8[j])
    aS=[]
    i=0
    while len(aS)<n:
        m=min(aR0)
        if m==100:
            break
        for j in range(aR0.count(m)):
            i=aR0.index(m)
            aR0[i]=100
            cx=compareXX(ab,i)
            if cx!='':
                aS.append(cx)
                aR.append(i)
    if t==0:
        print(aR)
        print('Лучше всего улучшат',aS)
    return(aS)     
# Пакет анализа 4
# Анализ 4 подряд движений
# Объединяет 4 движения и предлагает лучшее по числу улучшений/ухудшений
# Два небольших недостатка:
#   1 - число итераций - 729х729
#   2 - Возвращаемые 4 движения можно сократить, например X1C+X1C+X1C+X1D=X1C
# Параметр r - тип выбора
#               0 - Наибольший Good
#               1 - Наибольший Good при Bad=0
#               2 - Максимальный Good-Bad
#          t - если равен 0, то выводим на экран статистику
#          a - список движений N, если не пусто - выбираем только из них, иначе из всех
def analyse4(r,t,a=[]):
    aA=ibyn(a)
    lA=len(a)
    bg=-100
    l=len(M)
    if t==0:
        print('Анализ 4 движений')
    for i in range(len(MM)):
        for j in range(len(MM)):
            if lA>0 and (i//l not in aA or i%l not in aA or j//l not in aA or j%l not in aA):
                continue
            g,b=analyseMforBplus(merge2(MM[i],MM[j]))
            if r==0 and g>bg:
                bg=g
                best=[i,j]
                if t==0:
                    print('Пока лучшее по Good (',g,'/',b,'-',i,j,'(',N[i//l],N[i%l],N[j//l],N[j%l],')')
            elif r==1 and g>bg and b==0:
                bg=g
                best=[i,j]
                if t==0:
                    print('Пока лучшее по Good при Bad=0(',g,'/',b,'-',i,j,'(',N[i//l],N[i%l],N[j//l],N[j%l],')')                
            if r==2 and g-b>bg:
                bg=g
                best=[i,j]
                if t==0:
                    print('Пока лучшее по Good-Bad (',g,'/',b,'-',i,j,'(',N[i//l],N[i%l],N[j//l],N[j%l],')')
    ret=[N[best[0]//l],N[best[0]%l],N[best[1]//l],N[best[1]%l]]
    if t==0:
        print('Выбрано',ret)
    return(ret)
# Пакет анализа 5
# Аналогичен пакету 4, но чило движений плавающее от 1 до n
# Объединяет движения и предлагает лучшее по числу улучшений/ухудшений
# Параметр r - тип выбора
#               0 - Наибольший Good
#               1 - Наибольший Good при Bad=0
#               2 - Максимальный Good-Bad
#          t - если равен 0, то выводим на экран статистику
#          a - список движений N, выбираем только из них
#          n - максимальное число движений подряд. В зависимости от размера списка может меняться в меньшую сторону
def analyse5(r,t,a,n):
    aA=ibyn(a)
    lA=len(a)
    if lA in [4,5,6,7,8,9] and n>4:
        n=4
    elif lA in [10,11,12,13,14,15] and n>3:
        n=3
    elif lA>=16 and n>2:
        n=2
    elif lA<=3 and n>5:
        n=5
    bg=-100
    l=len(M)
    aR=['Good','Good при Bad=0','Good-Bad']
    
    for m in range(n):
        if t==0:
            print('Анализ ',m+1,' движений')
        #print(aA,m+1)
        aT=build_arr(aA,m+1)
        #print(aT)
        for i in aT:
            aM=mergeM(i)
            nN=names(i,1)
            g,b=analyseMforBplus(aM) 
            
            if (r==0 and g>bg) or (r==1 and g>bg and b==0) or (r==2 and g-b>bg):
                bg=g
                best=i
                if t==0:
                    print('Пока лучшее по ',aR[r],' (',g,'/',b,'-',nN,')') 
    ret=names(best,0)
    if t==0:
        print('Выбрано',ret)
    return(ret)
# Функция по списку движений N возвращает их индексы
# Параметр aI - список индексов движений
#           m - число движений в одной комбинации (от 1 до 5)
# Например, для aN=[2,3,4] и m=2 вернется [[2,2],[2,3],[2,4],[3,2],[3,3],[3,4],[4,2],[4,3],[4,4]]
def build_arr(aI,m):
    ar=[]
    if m==1:
        for i1 in aI:
            ar.append([i1])
    elif m==2:
        for i1 in aI:
            for i2 in aI:
                ar.append([i1,i2])
    elif m==3:
        for i1 in aI:
            for i2 in aI:
                for i3 in aI:
                    ar.append([i1,i2,i3])
    elif m==4:
        for i1 in aI:
            for i1 in aI:
                for i2 in aI:
                    for i3 in aI:
                        for i4 in aI:
                            ar.append([i1,i2,i3,i4])
    elif m==5:
        for i1 in aI:
            for i1 in aI:
                for i2 in aI:
                    for i3 in aI:
                        for i4 in aI:
                            for i5 in aI:
                                ar.append([i1,i2,i3,i4,i5])
 
    return(ar)  
# Функция по списку индексов движений возвращает список названий движений N
# Параметр aN - список индексов движений
#           t - 0 - вертуть список названий движений
#               1 - вертуть строку названий движений
def names(aI,t):
    ar=[]
    ret=''
    for j in aI:
        ar.append(N[j])
        ret+=N[j]+' '
    if t==0:
        return(ar)    
    else:
        return(ret)
# Функция по списку движений N возвращает их индексы
# Параметр aN - список движений типа n
# Например, для aN=['X1C','X2D','Z3O'] вернется [0,4,26]
def ibyn(aN):
    ar=[]
    for j in aN:
        i=N.index(j)
        ar.append(i)
    return(ar)         
# Функция поиска оптимального хода от обратного состояния
# Параметр t -  0 - поиск для одного хода
#               1 - поиск для двух ходов
# Используется в пакете анализа 2
# Возвращает всегда два значения. Если двойным ходом решается кубик - вертнутся два ходя, иначе - один, а второй=-1
def findbest2(n,t):
    mBv=[]
    mBi=[]
    oi=analyseB(1,2)
    for i in range(len(M)):
        if t==0:
            if i==Bl:
                continue
            else:
                r2=analyseM(i,1)
                #print('Движение',N[i],'может доусстановить',r2,'элементов')
        else:
            if i==Bl:
                print('Движение',N[i],'пропускаем, чтобы не было цикла')
                continue
            else:    
                r2=analyseMforB(i,1)
                print('Движение',N[i],'имеет',r2,'общих точек')
        ins=True
        for j in range(len(mBv)):
            if r2>=mBv[j]:
                mBv.insert(j,r2)
                mBi.insert(j,i)
                ins=False
                break
        if ins:
            mBv.append(r2)
            mBi.append(i)
    print('mBv',mBv)
    print('mBi',mBi)
    if mBv[0]==oi:
        print('Решено за 1 ход')
        return(mBi[0],-1)
    b=-100
    b1=-1
    b2=-1
    for i in range(n):
        if mBv[i]==0:
            print('Остальные варианты нулевые - не рассматриваем')
            break
        print('Вариант',i+1,'из',n)
        analyseMforB(mBi[i],0)
        for j in range(len(M)):
            if t==0:
                r2=analyseM2(mBi[i],j)
            else:
                r2=analyseMforB2(mBi[i],j)
                print('Для варианта',mBi[i],'(',N[mBi[i]],') пробуем мержить',j,'(',N[j],')результат',r2)
                if r2>b:
                    b=r2
                    b1=mBi[i]
                    b2=j
                    print('Пока это лучшее. Для решения нужно',oi)
                    if r2==oi:
                        g,b=analyseMforBplus(merge(mBi[i],j))
                        if b==0:
                            print('И это решает кубик за 2 хода!!!')
                            return(b1,b2)
                        else:    
                            print_cube()
                            print('Текущее состояние кубика')
                            analyse(0)
                            print('Не установлено точек',analyse(1))
                            print('Обратное состояние')
                            analyseB(0,0)
                            print('План построения от обратного')
                            analyseB(1,0)
                            print('Первое движение варианта',N[mBi[i]])
                            print(M[mBi[i]])                        
                            print('Второе движение варианта',N[j])
                            print(M[j])
                            print('Мерж движений',N[mBi[i]],'и',N[j])
                            print(merge(mBi[i],j))                        
    b2=-1
    return(b1,b2)
# Сама программа
init() # Генерация кубика в собранном состоянии
init_merge() # Генерация движений для пар движений
global mess # Объявление глобальных переменных для доступа из всех функций
global solve
#global solv
#solv=''
# Печатаем начальный кубик цифрами
print_cube()
# Печатаем начальный кубик цветами
print_cubeC()
# Вариант разборки и обратной сборки из 4 движений
mess='Y1D Z2C X2D X3O'
solve='X3C X2D Z2O Y1D'
# Генрация случайной авторазборки и сборки к нему
#mess,solve = random_mess(4) # Закомментировать, если нужно тестировать свой вариант
print('Алгоритм разборки')
print(mess)
print('Алгоритм быстрой сборки')
print(solve)
print()
do_do(mess) # Выполнение разборки кубика
print_cube() # Печать кубика после разборки
#do_do(solve) # Выполнение сборки кубика по готовой сборке
#print_cubeC() # Печать кубика после сборки
print('Попытка автоматического решения')
auto_solve2(20)
print_cubeC() # Печать кубика после попытки сборки
analyse(0) # Печать результатов анализа сборки
r=analyse(1) # Сколько квадратов не решено
if r==54:
    print('Решено')
else:
    print('Установлено',r,'элементов')
window.mainloop()

